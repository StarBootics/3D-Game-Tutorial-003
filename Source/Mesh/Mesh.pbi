; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V2.0.0 Beta 7
; Project name : OpenGL 3D Game Tutorial
; File name : Mesh.pbi
; File Version : 0.0.0
; Programmation : In progress
; Programmed by : Guillaume Saumure
; AKA : StarBootics
; E-mail : gsaumure@cgocable.ca
; Creation Date : November 10th, 2021
; Last update : July 22nd, 2022
; Coded for PureBasic : V6.00 LTS
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; The MIT License (MIT)
; 
; Copyright (c) 2022 Guillaume Saumure
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
; associated documentation files (the "Software"), to deal in the Software without restriction, including 
; without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
; copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the 
; following conditions:
; 
; The above copyright notice and this permission notice shall be included in all copies or substantial 
; portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
; LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
; EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
; THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule Mesh
  
  Interface Mesh
    
    GetName.s()
    GetVertices.i()
    GetIndices.i()
    GetIndiceCount.l()
    GetVertexArrayObjectID.l()
    SetName(Name.s)
    SetVertices(*Vertex.Vertex::Vertex)
    SetIndice(*Indice.Indice3::Indice3)
    SetIndiceCount(IndiceCount.l)
    SetVertexArrayObjectID(VertexArrayObjectID.l)
    AddVerticesEx(*Vertex.Vertex::Vertex)
    AddIndicesEx(*Indice.Indice3::Indice3)
    SelectVertices.i(Index.l)
    SelectIndices.i(Index.l)
    FirstVertices.i()
    FirstIndices.i()
    LastVertices.i()
    LastIndices.i()
    PreviousVertices.i()
    PreviousIndices.i()
    NextVertices.i()
    NextIndices.i()
    DeleteVertices()
    DeleteIndices()
    ResetVertices()
    ResetIndices()
    ClearVertices()
    ClearIndices()
    VertexIndex.l()
    IndiceIndex.l()
    VerticesSize.l()
    IndicesSize.l()
    CreateMeshFile.i(FileName.s)
    ReadMeshFile.i(FileName.s)
    SendToGPU()
    FreeFromGPU()
    BindVertexArrayObject()
    Draw()
    UnbindVertexArrayObject()
    Free()
    
  EndInterface
  
  Declare.i New()
  
EndDeclareModule

Module Mesh
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structure declaration <<<<<

  Structure Private_Members
    
    VirtualTable.i
    Name.s
    List Vertices.Vertex::Vertex()
    List Indices.Indice3::Indice3()
    IndiceCount.l
    VertexArrayObjectID.l
    
  EndStructure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The observators <<<<<

  Procedure.s GetName(*This.Private_Members)
    
    ProcedureReturn *This\Name
  EndProcedure
  
  Procedure.i GetVertices(*This.Private_Members)
    
    ProcedureReturn *This\Vertices()
  EndProcedure
  
  Procedure.i GetIndices(*This.Private_Members)
    
    ProcedureReturn *This\Indices()
  EndProcedure
  
  Procedure.l GetIndiceCount(*This.Private_Members)
    
    ProcedureReturn *This\IndiceCount
  EndProcedure
  
  Procedure.l GetVertexArrayObjectID(*This.Private_Members)
    
    ProcedureReturn *This\VertexArrayObjectID
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The mutators <<<<<

  Procedure SetName(*This.Private_Members, Name.s)
    
    *This\Name = Name
    
  EndProcedure
  
  Procedure SetVertices(*This.Private_Members, *Vertex.Vertex::Vertex)
    
    If *This\Vertices() <> #Null
      *This\Vertices()\Free()
    EndIf
    
    *This\Vertices() = *Vertex
    
  EndProcedure
  
  Procedure SetIndices(*This.Private_Members, *Indice.Indice3::Indice3)
    
    If *This\Indices() <> #Null
      *This\Indices()\Free()
    EndIf
    
    *This\Indices() = *Indice
    
  EndProcedure
  
  Procedure SetIndiceCount(*This.Private_Members, IndiceCount.l)
    
    *This\IndiceCount = IndiceCount
    
  EndProcedure
  
  Procedure SetVertexArrayObjectID(*This.Private_Members, VertexArrayObjectID.l)
    
    *This\VertexArrayObjectID = VertexArrayObjectID
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The AddEx to linked list operator(s) <<<<<

  Procedure AddVerticesEx(*This.Private_Members, *Vertex.Vertex::Vertex)
    
    AddElement(*This\Vertices())
    *This\Vertices() = *Vertex
    
  EndProcedure
  
  Procedure AddIndicesEx(*This.Private_Members, *Indice.Indice3::Indice3)
    
    AddElement(*This\Indices())
    *This\Indices() = *Indice
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Select in linked list operator(s) <<<<<

  Procedure.i SelectVertices(*This.Private_Members, Index.l)
    
    ProcedureReturn SelectElement(*This\Vertices(), Index)
  EndProcedure
  
  Procedure.i SelectIndices(*This.Private_Members, Index.l)
    
    ProcedureReturn SelectElement(*This\Indices(), Index)
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The First element in linked list operator(s) <<<<<

  Procedure.i FirstVertices(*This.Private_Members)
    
    ProcedureReturn FirstElement(*This\Vertices())
  EndProcedure
  
  Procedure.i FirstIndices(*This.Private_Members)
    
    ProcedureReturn FirstElement(*This\Indices())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Last element in linked list operator(s) <<<<<

  Procedure.i LastVertices(*This.Private_Members)
    
    ProcedureReturn LastElement(*This\Vertices())
  EndProcedure
  
  Procedure.i LastIndices(*This.Private_Members)
    
    ProcedureReturn LastElement(*This\Indices())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Previous element in linked list operator(s) <<<<<

  Procedure.i PreviousVertices(*This.Private_Members)
    
    ProcedureReturn PreviousElement(*This\Vertices())
  EndProcedure
  
  Procedure.i PreviousIndices(*This.Private_Members)
    
    ProcedureReturn PreviousElement(*This\Indices())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Next element in linked list operator(s) <<<<<

  Procedure.i NextVertices(*This.Private_Members)
    
    ProcedureReturn NextElement(*This\Vertices())
  EndProcedure
  
  Procedure.i NextIndices(*This.Private_Members)
    
    ProcedureReturn NextElement(*This\Indices())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Delete element from linked list operator(s) <<<<<

  Procedure DeleteVertices(*This.Private_Members)
    
    If *This\Vertices() <> #Null
      *This\Vertices()\Free()
    EndIf
    
    DeleteElement(*This\Vertices())
    
  EndProcedure
  
  Procedure DeleteIndices(*This.Private_Members)
    
    If *This\Indices() <> #Null
      *This\Indices()\Free()
    EndIf
    
    DeleteElement(*This\Indices())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Reset linked list operator(s) <<<<<

  Procedure ResetVertices(*This.Private_Members)
    
    ResetList(*This\Vertices())
    
  EndProcedure
  
  Procedure ResetIndices(*This.Private_Members)
    
    ResetList(*This\Indices())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Clear linked list operator(s) <<<<<

  Procedure ClearVertices(*This.Private_Members)
    
    ForEach *This\Vertices()
      If *This\Vertices() <> #Null
        *This\Vertices()\Free()
      EndIf
    Next
    
    ClearList(*This\Vertices())
    
  EndProcedure
  
  Procedure ClearIndices(*This.Private_Members)
    
    ForEach *This\Indices()
      If *This\Indices() <> #Null
        *This\Indices()\Free()
      EndIf
    Next
    
    ClearList(*This\Indices())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Index in the linked list operator(s) <<<<<

  Procedure.l VertexIndex(*This.Private_Members)
    
    ProcedureReturn ListIndex(*This\Vertices())
  EndProcedure
  
  Procedure.l IndiceIndex(*This.Private_Members)
    
    ProcedureReturn ListIndex(*This\Indices())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Size of the linked list operator(s) <<<<<

  Procedure.l VerticesSize(*This.Private_Members)
    
    ProcedureReturn ListSize(*This\Vertices())
  EndProcedure
  
  Procedure.l IndicesSize(*This.Private_Members)
    
    ProcedureReturn ListSize(*This\Indices())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Create Binary File <<<<<

  Procedure.i CreateMeshFile(*This.Private_Members, FileName.s)
    
    FileID = CreateFile(#PB_Any, FileName)
    
    If IsFile(FileID)
    
      WriteStringN(FileID, *This\Name)
    
      WriteLong(FileID, ListSize(*This\Vertices()))
      
      ForEach *This\Vertices()
        *This\Vertices()\WriteVertex(FileID)
      Next
    
      WriteLong(FileID, ListSize(*This\Indices()))
      
      ForEach *This\Indices()
        *This\Indices()\WriteIndice3(FileID)
      Next
    
      CloseFile(FileID)
      Success.i = 1
    
    Else
    
      Success = -1
    
    EndIf
    
    ProcedureReturn Success
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Read Binary File <<<<<

  Procedure.i ReadMeshFile(*This.Private_Members, FileName.s)
    
    FileID = ReadFile(#PB_Any, FileName)
    
    If IsFile(FileID)
    
      *This\Name = ReadString(FileID)
    
      Vertices_Max.l = ReadLong(FileID) - 1
      
      For VerticesID.l = 0 To Vertices_Max
        AddElement(*This\Vertices())
        *This\Vertices() = Vertex::New()
        *This\Vertices()\ReadVertex(FileID)
      Next
    
      Indices_Max.l = ReadLong(FileID) - 1
      
      For IndicesID.l = 0 To Indices_Max
        AddElement(*This\Indices())
        *This\Indices() = Indice3::New()
        *This\Indices()\ReadIndice3(FileID)
      Next
    
      CloseFile(FileID)
      
      Success.i = 1
    
    Else
      
      Success = -1
      
    EndIf
    
    ProcedureReturn Success
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendToGPU operator <<<<<
  
  Procedure SendToGPU(*This.Private_Members)
    
    VertexBuffer.i = AllocateMemory(ListSize(*This\Vertices()) * Vertex::#MEMORY_SIZE)
    Ptr.i = VertexBuffer
    
    ForEach *This\Vertices()
      Ptr = *This\Vertices()\Interleave(Ptr)
    Next
    
    *This\IndiceCount = ListSize(*This\Indices())
    
    IndiceBuffer.i = AllocateMemory(*This\IndiceCount * Indice3::#MEMORY_SIZE)
    Ptr.i = IndiceBuffer
    
    ForEach *This\Indices()
      CopyMemory(*This\Indices()\Access(), Ptr, Indice3::#MEMORY_SIZE)
      Ptr + Indice3::#MEMORY_SIZE
    Next
    
    GL30::glGenVertexArrays(1, @*This\VertexArrayObjectID)
    GL30::glBindVertexArray(*This\VertexArrayObjectID)
    
    GL20::glGenBuffers(1, @VertexBufferObjectID.l)
    GL20::glBindBuffer(OGL::#GL_ARRAY_BUFFER, VertexBufferObjectID)
    GL20::glBufferData(OGL::#GL_ARRAY_BUFFER, MemorySize(VertexBuffer), VertexBuffer, OGL::#GL_STATIC_DRAW)
    
    GL20::glGenBuffers(1, @IndiceBufferObjectID.l)
    GL20::glBindBuffer(OGL::#GL_ELEMENT_ARRAY_BUFFER, IndiceBufferObjectID)
    GL20::glBufferData(OGL::#GL_ELEMENT_ARRAY_BUFFER, MemorySize(IndiceBuffer), IndiceBuffer, OGL::#GL_STATIC_DRAW)
    
    GL20::glEnableVertexAttribArray(0)
    GL20::glEnableVertexAttribArray(1)
    GL20::glEnableVertexAttribArray(2)
    GL20::glEnableVertexAttribArray(3)
    
    GL20::glVertexAttribPointer(0, 3, #GL_FLOAT, #GL_FALSE, Vertex::#MEMORY_SIZE, 0)
    GL20::glVertexAttribPointer(1, 3, #GL_FLOAT, #GL_FALSE, Vertex::#MEMORY_SIZE, 12)
    GL20::glVertexAttribPointer(2, 3, #GL_FLOAT, #GL_FALSE, Vertex::#MEMORY_SIZE, 24)
    GL20::glVertexAttribPointer(3, 2, #GL_FLOAT, #GL_FALSE, Vertex::#MEMORY_SIZE, 36)
    
    GL20::glDisableVertexAttribArray(0)
    GL20::glDisableVertexAttribArray(1)
    GL20::glDisableVertexAttribArray(2)
    GL20::glDisableVertexAttribArray(3)
    
    GL30::glBindVertexArray(0)
    
    FreeMemory(VertexBuffer)
    FreeMemory(IndiceBuffer)
    
    GL20::glDeleteBuffers(1, @VertexBufferObjectID)
    GL20::glDeleteBuffers(1, @IndiceBufferObjectID)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The FreeFromGPU operator <<<<<
  
  Procedure FreeFromGPU(*This.Private_Members)
    
    GL30::glDeleteVertexArrays(1, @*This\VertexArrayObjectID)
    
    *This\VertexArrayObjectID = 0
    
  EndProcedure
  
  Procedure BindVertexArrayObject(*This.Private_Members)
    
    GL30::glBindVertexArray(*This\VertexArrayObjectID)
    
    GL20::glEnableVertexAttribArray(0)
    GL20::glEnableVertexAttribArray(1)
    GL20::glEnableVertexAttribArray(2)
    GL20::glEnableVertexAttribArray(3)
    
  EndProcedure 
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Draw operator <<<<<
  
  Procedure Draw(*This.Private_Members)
    
    GL20::glDrawElements(#GL_TRIANGLES, 3 * *This\IndiceCount, #GL_UNSIGNED_INT, 0)
    
  EndProcedure
  
  Procedure UnbindVertexArrayObject(*This.Private_Members)
    
    GL20::glDisableVertexAttribArray(0)
    GL20::glDisableVertexAttribArray(1)
    GL20::glDisableVertexAttribArray(2)
    GL20::glDisableVertexAttribArray(3)
    
    GL30::glBindVertexArray(0)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    ForEach *This\Vertices()
      If *This\Vertices() <> #Null
        *This\Vertices()\Free()
      EndIf
    Next
    
    ForEach *This\Indices()
      If *This\Indices() <> #Null
        *This\Indices()\Free()
      EndIf
    Next
    
    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructor <<<<<

  Procedure.i New()
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetName()
    Data.i @GetVertices()
    Data.i @GetIndices()
    Data.i @GetIndiceCount()
    Data.i @GetVertexArrayObjectID()
    Data.i @SetName()
    Data.i @SetVertices()
    Data.i @SetIndices()
    Data.i @SetIndiceCount()
    Data.i @SetVertexArrayObjectID()
    Data.i @AddVerticesEx()
    Data.i @AddIndicesEx()
    Data.i @SelectVertices()
    Data.i @SelectIndices()
    Data.i @FirstVertices()
    Data.i @FirstIndices()
    Data.i @LastVertices()
    Data.i @LastIndices()
    Data.i @PreviousVertices()
    Data.i @PreviousIndices()
    Data.i @NextVertices()
    Data.i @NextIndices()
    Data.i @DeleteVertices()
    Data.i @DeleteIndices()
    Data.i @ResetVertices()
    Data.i @ResetIndices()
    Data.i @ClearVertices()
    Data.i @ClearIndices()
    Data.i @VertexIndex()
    Data.i @IndiceIndex()
    Data.i @VerticesSize()
    Data.i @IndicesSize()
    Data.i @CreateMeshFile()
    Data.i @ReadMeshFile()
    Data.i @SendToGPU()
    Data.i @FreeFromGPU()
    Data.i @BindVertexArrayObject()
    Data.i @Draw()
    Data.i @UnbindVertexArrayObject()
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (496000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.00 LTS (Linux - x64)
; Folding = --------
; EnableXP
; CompileSourceDirectory