; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V2.0.0 Beta 7
; Project name : the project name here
; File name : File name here
; File Version : 0.0.0
; Programmation : In progress
; Programmed by : Guillaume Saumure
; AKA : StarBootics
; E-mail : gsaumure@cgocable.ca
; Creation Date : July 29th, 2022
; Last update : July 29th, 2022
; Coded for PureBasic : V6.00 LTS
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; The MIT License (MIT)
; 
; Copyright (c) 2022 Guillaume Saumure
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
; associated documentation files (the "Software"), to deal in the Software without restriction, including 
; without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
; copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the 
; following conditions:
; 
; The above copyright notice and this permission notice shall be included in all copies or substantial 
; portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
; LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
; EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
; THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule Material
  
  Interface Material
    
    GetTextures.i()
    GetColors.i()
    GetFloats.f()
    GetIntegers.l()
    SetTextures(*Textures.Texture::Texture)
    SetColors(*Colors.Color3f::Color3f)
    SetFloats(Floats.f)
    SetIntegers(Integers.l)
    Clear()
    Copy.i()
    AddTexturesEx(Key.s, *Textures.Texture::Texture)
    AddColorsEx(Key.s, *Colors.Color3f::Color3f)
    AddFloatsEx(Key.s, Floats.f)
    AddIntegersEx(Key.s, Integers.l)
    ClearTextures()
    ClearColors()
    ClearFloats()
    ClearIntegers()
    TexturesSize.l()
    ColorsSize.l()
    FloatsSize.l()
    IntegersSize.l()
    ResetTextures()
    ResetColors()
    ResetFloats()
    ResetIntegers()
    DeleteTextures()
    DeleteColors()
    DeleteFloats()
    DeleteIntegers()
    FindTextures.i(Key.s)
    FindColors.i(Key.s)
    FindFloats.i(Key.s)
    FindIntegers.i(Key.s)
    NextTextures.i()
    NextColors.i()
    NextFloats.i()
    NextIntegers.i()
    TexturesKey.s()
    ColorsKey.s()
    FloatsKey.s()
    IntegersKey.s()
    CreateMaterialFile.i(FileName.s)
    ReadMaterialFile.i(FileName.s)
    
    CompilerIf Defined(ShaderProgram, #PB_Module)
      BindTexture(ActiveTexture.l, TextureName.s, *DefaultMaterial)
      SendColorUniform(ColorName.s, *ShaderProgram.ShaderProgram::ShaderProgram, *DefaultMaterial)
      SendFloatUniform(FloatName.s, *ShaderProgram.ShaderProgram::ShaderProgram, *DefaultMaterial)
      SendIntegerUniform(IntegerName.s, *ShaderProgram.ShaderProgram::ShaderProgram, *DefaultMaterial)
    CompilerEndIf
    
    Free()
    
  EndInterface
  
  Declare.i New()
  
EndDeclareModule

Module Material
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structure declaration <<<<<

  Structure Private_Members
    
    VirtualTable.i
    Map Textures.Texture::Texture(16)
    Map Colors.Color3f::Color3f(16)
    Map Floats.f(16)
    Map Integers.l(16)
    
  EndStructure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The observators <<<<<

  Procedure.i GetTextures(*This.Private_Members)
    
    ProcedureReturn *This\Textures()
  EndProcedure
  
  Procedure.i GetColors(*This.Private_Members)
    
    ProcedureReturn *This\Colors()
  EndProcedure
  
  Procedure.f GetFloats(*This.Private_Members)
    
    ProcedureReturn *This\Floats()
  EndProcedure
  
  Procedure.l GetIntegers(*This.Private_Members)
    
    ProcedureReturn *This\Integers()
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The mutators <<<<<

  Procedure SetTextures(*This.Private_Members, *Textures.Texture::Texture)
    
    If *This\Textures() <> #Null
      *This\Textures()\Free()
    EndIf
    
    *This\Textures() = *Textures
    
  EndProcedure
  
  Procedure SetColors(*This.Private_Members, *Colors.Color3f::Color3f)
    
    If *This\Colors() <> #Null
      *This\Colors()\Free()
    EndIf
    
    *This\Colors() = *Colors
    
  EndProcedure
  
  Procedure SetFloats(*This.Private_Members, Floats.f)
    
    *This\Floats() = Floats
    
  EndProcedure
  
  Procedure SetIntegers(*This.Private_Members, Integers.l)
    
    *This\Integers() = Integers
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Clear operator <<<<<

  Procedure Clear(*This.Private_Members)

    ForEach *This\Textures()
      If *This\Textures() <> #Null
        *This\Textures()\Free()
      EndIf
    Next
    
    ClearMap(*This\Textures())
    
    ForEach *This\Colors()
      If *This\Colors() <> #Null
        *This\Colors()\Free()
      EndIf
    Next
    
    ClearMap(*This\Colors())
    
    ClearMap(*This\Floats())
    
    ClearMap(*This\Integers())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Copy operator <<<<<

  Procedure.i Copy(*This.Private_Members)
    
    *Copy.Private_Members = AllocateStructure(Private_Members)
    *Copy\VirtualTable = ?START_METHODS
    
    ForEach *This\Textures()
      AddMapElement(*Copy\Textures(), MapKey(*This\Textures()))
      *Copy\Textures() = *This\Textures()\Copy()
    Next
    
    ForEach *This\Colors()
      AddMapElement(*Copy\Colors(), MapKey(*This\Colors()))
      *Copy\Colors() = *This\Colors()\Copy()
    Next
    
    CopyMap(*This\Floats(), *Copy\Floats())
    CopyMap(*This\Integers(), *Copy\Integers())
    
    ProcedureReturn *Copy
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The AddEx to map operator(s) <<<<<

  Procedure AddTexturesEx(*This.Private_Members, Key.s, *Textures.Texture::Texture)
    
    AddMapElement(*This\Textures(), Key)
    *This\Textures() = *Textures
    
  EndProcedure
  
  Procedure AddColorsEx(*This.Private_Members, Key.s, *Colors.Color3f::Color3f)
    
    AddMapElement(*This\Colors(), Key)
    *This\Colors() = *Colors
    
  EndProcedure
  
  Procedure AddFloatsEx(*This.Private_Members, Key.s, Floats.f)
    
    AddMapElement(*This\Floats(), Key)
    *This\Floats() = Floats
    
  EndProcedure
  
  Procedure AddIntegersEx(*This.Private_Members, Key.s, Integers.l)
    
    AddMapElement(*This\Integers(), Key)
    *This\Integers() = Integers
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Clear map operator(s) <<<<<

  Procedure ClearTextures(*This.Private_Members)
    
    ForEach *This\Textures()
      If *This\Textures() <> #Null
        *This\Textures()\Free()
      EndIf
    Next
    
    ClearMap(*This\Textures())
    
  EndProcedure
  
  Procedure ClearColors(*This.Private_Members)
    
    ForEach *This\Colors()
      If *This\Colors() <> #Null
        *This\Colors()\Free()
      EndIf
    Next
    
    ClearMap(*This\Colors())
    
  EndProcedure
  
  Procedure ClearFloats(*This.Private_Members)
    
    ClearMap(*This\Floats())
    
  EndProcedure
  
  Procedure ClearIntegers(*This.Private_Members)
    
    ClearMap(*This\Integers())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The map Size operator(s) <<<<<

  Procedure.l TexturesSize(*This.Private_Members)
    
    ProcedureReturn MapSize(*This\Textures())
  EndProcedure
  
  Procedure.l ColorsSize(*This.Private_Members)
    
    ProcedureReturn MapSize(*This\Colors())
  EndProcedure
  
  Procedure.l FloatsSize(*This.Private_Members)
    
    ProcedureReturn MapSize(*This\Floats())
  EndProcedure
  
  Procedure.l IntegersSize(*This.Private_Members)
    
    ProcedureReturn MapSize(*This\Integers())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Reset map operator(s) <<<<<

  Procedure ResetTextures(*This.Private_Members)
    
    ResetMap(*This\Textures())
    
  EndProcedure
  
  Procedure ResetColors(*This.Private_Members)
    
    ResetMap(*This\Colors())
    
  EndProcedure
  
  Procedure ResetFloats(*This.Private_Members)
    
    ResetMap(*This\Floats())
    
  EndProcedure
  
  Procedure ResetIntegers(*This.Private_Members)
    
    ResetMap(*This\Integers())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Delete map element operator(s) <<<<<

  Procedure DeleteTextures(*This.Private_Members)
    
    If *This\Textures() <> #Null
      *This\Textures()\Free()
    EndIf
    
    DeleteMapElement(*This\Textures())
    
  EndProcedure
  
  Procedure DeleteColors(*This.Private_Members)
    
    If *This\Colors() <> #Null
      *This\Colors()\Free()
    EndIf
    
    DeleteMapElement(*This\Colors())
    
  EndProcedure
  
  Procedure DeleteFloats(*This.Private_Members)
    
    DeleteMapElement(*This\Floats())
    
  EndProcedure
  
  Procedure DeleteIntegers(*This.Private_Members)
    
    DeleteMapElement(*This\Integers())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Find map element operator(s) <<<<<

  Procedure.i FindTextures(*This.Private_Members, Key.s)
    
    ProcedureReturn FindMapElement(*This\Textures(), Key)
  EndProcedure
  
  Procedure.i FindColors(*This.Private_Members, Key.s)
    
    ProcedureReturn FindMapElement(*This\Colors(), Key)
  EndProcedure
  
  Procedure.i FindFloats(*This.Private_Members, Key.s)
    
    ProcedureReturn FindMapElement(*This\Floats(), Key)
  EndProcedure
  
  Procedure.i FindIntegers(*This.Private_Members, Key.s)
    
    ProcedureReturn FindMapElement(*This\Integers(), Key)
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Next map element operator(s) <<<<<

  Procedure.i NextTextures(*This.Private_Members)
    
    ProcedureReturn NextMapElement(*This\Textures())
  EndProcedure
  
  Procedure.i NextColors(*This.Private_Members)
    
    ProcedureReturn NextMapElement(*This\Colors())
  EndProcedure
  
  Procedure.i NextFloats(*This.Private_Members)
    
    ProcedureReturn NextMapElement(*This\Floats())
  EndProcedure
  
  Procedure.i NextIntegers(*This.Private_Members)
    
    ProcedureReturn NextMapElement(*This\Integers())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The map Key operator(s) <<<<<

  Procedure.s TexturesKey(*This.Private_Members)
    
    ProcedureReturn MapKey(*This\Textures())
  EndProcedure
  
  Procedure.s ColorsKey(*This.Private_Members)
    
    ProcedureReturn MapKey(*This\Colors())
  EndProcedure
  
  Procedure.s FloatsKey(*This.Private_Members)
    
    ProcedureReturn MapKey(*This\Floats())
  EndProcedure
  
  Procedure.s IntegersKey(*This.Private_Members)
    
    ProcedureReturn MapKey(*This\Integers())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Create Binary File <<<<<

  Procedure.i CreateMaterialFile(*This.Private_Members, FileName.s)
    
    FileID = CreateFile(#PB_Any, FileName)
    
    If IsFile(FileID)

      WriteLong(FileID, MapSize(*This\Textures()))
      
      ForEach *This\Textures()
        WriteStringN(FileID, MapKey(*This\Textures()))
        *This\Textures()\WriteTexture(FileID)
      Next
    
      WriteLong(FileID, MapSize(*This\Colors()))
      
      ForEach *This\Colors()
        WriteStringN(FileID, MapKey(*This\Colors()))
        *This\Colors()\WriteColor3f(FileID)
      Next
    
      WriteLong(FileID, MapSize(*This\Floats()))
      
      ForEach *This\Floats()
        WriteStringN(FileID, MapKey(*This\Floats()))
        WriteFloat(FileID, *This\Floats())
      Next
    
      WriteLong(FileID, MapSize(*This\Integers()))
      
      ForEach *This\Integers()
        WriteStringN(FileID, MapKey(*This\Integers()))
        WriteLong(FileID, *This\Integers())
      Next
    
      CloseFile(FileID)
      Success.i = 1
    
    Else
    
      Success = -1
    
    EndIf
    
    ProcedureReturn Success
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Read Binary File <<<<<

  Procedure.i ReadMaterialFile(*This.Private_Members, FileName.s)
    
    FileID = ReadFile(#PB_Any, FileName)
    
    If IsFile(FileID)
    
      Textures_Max.l = ReadLong(FileID) - 1
      
      For TexturesID.l = 0 To Textures_Max
        AddMapElement(*This\Textures(), ReadString(FileID))
        *This\Textures() = Texture::New()
        *This\Textures()\ReadTexture(FileID)
      Next
    
      Colors_Max.l = ReadLong(FileID) - 1
      
      For ColorsID.l = 0 To Colors_Max
        AddMapElement(*This\Colors(), ReadString(FileID))
        *This\Colors() = Color3f::New()
        *This\Colors()\ReadColor3f(FileID)
      Next
    
      Floats_Max.l = ReadLong(FileID) - 1
      
      For FloatsID.l = 0 To Floats_Max
        AddMapElement(*This\Floats(), ReadString(FileID))
        *This\Floats() = ReadFloat(FileID)
      Next
    
      Integers_Max.l = ReadLong(FileID) - 1
      
      For IntegersID.l = 0 To Integers_Max
        AddMapElement(*This\Integers(), ReadString(FileID))
        *This\Integers() = ReadLong(FileID)
      Next
    
      CloseFile(FileID)
      
      Success.i = 1
    
    Else
      
      Success = -1
      
    EndIf
    
    ProcedureReturn Success
  EndProcedure
  
  CompilerIf Defined(ShaderProgram, #PB_Module)
    
    ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ; <<<<< Nom de la procédure <<<<<
    
    Procedure BindTexture(*This.Private_Members, ActiveTexture.l, TextureName.s, *DefaultMaterial.Private_Members)
      
      GL20::glActiveTexture(ActiveTexture)
      
      If FindTextures(*This, TextureName)
        GL30::glBindTexture(#GL_TEXTURE_2D, *This\Textures()\GetID())
      Else
        
        If FindTextures(*DefaultMaterial, TextureName)
          GL30::glBindTexture(#GL_TEXTURE_2D, *DefaultMaterial\Textures()\GetID())
        EndIf
        
      EndIf
      
    EndProcedure
    
    ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ; <<<<< Nom de la procédure <<<<<
    
    Procedure SendColorUniform(*This.Private_Members, ColorName.s, *ShaderProgram.ShaderProgram::ShaderProgram, *DefaultMaterial.Private_Members)
      
      If FindColors(*This, ColorName)
        *ShaderProgram\SendUniformColor3fv(ColorName, *This\Colors())
      Else
        If FindColors(*DefaultMaterial, ColorName)
          *ShaderProgram\SendUniformColor3fv(ColorName, *DefaultMaterial\Colors())
        EndIf
      EndIf
      
    EndProcedure
    
    ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ; <<<<< Nom de la procédure <<<<<
    
    Procedure SendFloatUniform(*This.Private_Members, FloatName.s, *ShaderProgram.ShaderProgram::ShaderProgram, *DefaultMaterial.Private_Members)
      
      If FindFloats(*This, FloatName)
        *ShaderProgram\SendUniform1f(FloatName, *This\Floats())
      Else
        
        If FindFloats(*DefaultMaterial, FloatName)
          *ShaderProgram\SendUniform1f(FloatName, *DefaultMaterial\Floats())
        EndIf
        
      EndIf
      
    EndProcedure
    
    ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ; <<<<< Nom de la procédure <<<<<
    
    Procedure SendIntegerUniform(*This.Private_Members, IntegerName.s, *ShaderProgram.ShaderProgram::ShaderProgram, *DefaultMaterial.Private_Members)
      
      If FindIntegers(*This, IntegerName)
        *ShaderProgram\SendUniform1i(IntegerName, *This\Integers())
      Else
        
        If FindIntegers(*DefaultMaterial, IntegerName)
          *ShaderProgram\SendUniform1i(IntegerName, *DefaultMaterial\Integers())
        EndIf
        
      EndIf
      
    EndProcedure
    
  CompilerEndIf
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    ForEach *This\Textures()
      If *This\Textures() <> #Null
        *This\Textures()\Free()
      EndIf
    Next
    
    ForEach *This\Colors()
      If *This\Colors() <> #Null
        *This\Colors()\Free()
      EndIf
    Next
    
    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructor <<<<<

  Procedure.i New()
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetTextures()
    Data.i @GetColors()
    Data.i @GetFloats()
    Data.i @GetIntegers()
    Data.i @SetTextures()
    Data.i @SetColors()
    Data.i @SetFloats()
    Data.i @SetIntegers()
    Data.i @Clear()
    Data.i @Copy()
    Data.i @AddTexturesEx()
    Data.i @AddColorsEx()
    Data.i @AddFloatsEx()
    Data.i @AddIntegersEx()
    Data.i @ClearTextures()
    Data.i @ClearColors()
    Data.i @ClearFloats()
    Data.i @ClearIntegers()
    Data.i @TexturesSize()
    Data.i @ColorsSize()
    Data.i @FloatsSize()
    Data.i @IntegersSize()
    Data.i @ResetTextures()
    Data.i @ResetColors()
    Data.i @ResetFloats()
    Data.i @ResetIntegers()
    Data.i @DeleteTextures()
    Data.i @DeleteColors()
    Data.i @DeleteFloats()
    Data.i @DeleteIntegers()
    Data.i @FindTextures()
    Data.i @FindColors()
    Data.i @FindFloats()
    Data.i @FindIntegers()
    Data.i @NextTextures()
    Data.i @NextColors()
    Data.i @NextFloats()
    Data.i @NextIntegers()
    Data.i @TexturesKey()
    Data.i @ColorsKey()
    Data.i @FloatsKey()
    Data.i @IntegersKey()
    Data.i @CreateMaterialFile()
    Data.i @ReadMaterialFile()
    
    CompilerIf Defined(ShaderProgram, #PB_Module)
      Data.i @BindTexture()
      Data.i @SendColorUniform()
      Data.i @SendFloatUniform()
      Data.i @SendIntegerUniform()
    CompilerEndIf
    
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (658000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.00 LTS (Linux - x64)
; Folding = ----------
; EnableXP
; CompileSourceDirectory