; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V2.0.0 Beta 7
; Project name : OpenGL 3D Game Tutorial
; File name : ShaderProgram.pbi
; File Version : 0.0.1
; Programmation : In progress
; Programmed by : Guillaume Saumure
; AKA : StarBootics
; E-mail : gsaumure@cgocable.ca
; Creation Date : November 14th, 2021
; Last update : July 22nd, 2022
; Coded for PureBasic : V6.00 LTS
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; The MIT License (MIT)
; 
; Copyright (c) 2021 Guillaume Saumure
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
; associated documentation files (the "Software"), to deal in the Software without restriction, including 
; without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
; copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the 
; following conditions:
; 
; The above copyright notice and this permission notice shall be included in all copies or substantial 
; portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
; LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
; EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
; THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule ShaderProgram
  
  Interface ShaderProgram
    
    GetVSFileName.s()
    GetGSFileName.s()
    GetFSFileName.s()
    GetVertexShaderID.l()
    GetGeometryShaderID.l()
    GetFragmentShaderID.l()
    GetProgramID.l()
    GetUniforms.l()
    SetVSFileName(VSFileName.s)
    SetGSFileName(GSFileName.s)
    SetFSFileName(FSFileName.s)
    SetVertexShaderID(VertexShaderID.l)
    SetGeometryShaderID(GeometryShaderID.l)
    SetFragmentShaderID(FragmentShaderID.l)
    SetProgramID(ProgramID.l)
    SetUniforms(Uniforms.l)
    AddUniforms(UniformName.s)
    ClearUniforms()
    UniformsSize.l()
    ResetUniforms()
    DeleteUniforms()
    FindUniforms.i(UniformName.s)
    NextUniforms.i()
    UniformsKey.s()
    Compile(SourcePath.s, *RemoteBindAttribute)
    GetUniformLocations()
    SendUniformMatrix4fv(UniformName.s, *MatrixA.Matrix44f::Matrix44f)
    SendUniformVector3fv(UniformName.s, *VectorA.Vector3f::Vector3f)
    SendUniformVector2fv(UniformName.s, *VectorA.Vector2f::Vector2f)
    SendUniformColor3fv(UniformName.s, *ColorA.Color3f::Color3f)
    SendUniformColor4fv(UniformName.s, *ColorA.Color4f::Color4f)
    SendUniform1i(UniformName.s, Integer.l)
    SendUniform1f(UniformName.s, Float.f)
    Free()
    
  EndInterface
  
  Declare.i New(VSFileName.s, GSFileName.s, FSFileName.s)
  
EndDeclareModule

Module ShaderProgram
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structure declaration <<<<<

  Structure Private_Members
    
    VirtualTable.i
    VSFileName.s
    GSFileName.s
    FSFileName.s
    VertexShaderID.l
    GeometryShaderID.l
    FragmentShaderID.l
    ProgramID.l
    Map Uniforms.l()
    
  EndStructure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The prototype <<<<<
  
  Prototype BindAttribute(ProgramID.l)
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< LoadShaderSource (Private) <<<<<
  
  Procedure.s LoadShaderSource(FileName.s)
    
    If FileSize(FileName) = -1
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> LoadShaderSource() the file " + FileName + " don't exist !" )
      CompilerElse 
        MessageRequester("ShaderProgram -> LoadShaderSource()", "The file : " + FileName + " don't exist !")
        End
      CompilerEndIf
    EndIf
    
    FileID = ReadFile(#PB_Any, FileName)
    
    If FileID
      
      While Eof(FileID) = 0
        Source.s + ReadString(FileID) + #CRLF$
      Wend
      
      CloseFile(FileID)
      
    EndIf
    
    ProcedureReturn Source
  EndProcedure
  
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< CompileShaderSource (Private) <<<<<
  
  Procedure.l CompileShaderSource(FileName.s, ShaderSource.s, ShaderType.l)
    
    ShaderID.l = GL20::glCreateShader(ShaderType)
    ShaderBuffer = Ascii(ShaderSource)
    GL20::glShaderSource(ShaderID, 1, @ShaderBuffer, #Null)
    GL20::glCompileShader(ShaderID)
    
    GL20::glGetShaderiv(ShaderID, OGL::#GL_COMPILE_STATUS, @IsShaderCompiled.l)
    
    If IsShaderCompiled = #GL_FALSE
      
      Select ShaderType
          
        Case OGL::#GL_FRAGMENT_SHADER
          Type.s = "Fragment Shader"
          
        Case OGL::#GL_VERTEX_SHADER
          Type = "Vertex Shader"
          
        Case OGL::#GL_GEOMETRY_SHADER
          Type = "Geometry Shader"
          
      EndSelect 
      
      MaxLength.l = 0
      GL20::glGetShaderiv(ShaderID, OGL::#GL_INFO_LOG_LENGTH, @MaxLength)
      
      *ErrorLog = Ascii(Space(MaxLength))
      GL20::glGetShaderInfoLog(ShaderID, MaxLength, @MaxLength, *ErrorLog)
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> CompileShaderSource() " + Type + " : " + FileName + " : " + PeekS(*ErrorLog, -1, #PB_Ascii))
      CompilerElse 
        MessageRequester("ShaderProgram -> CompileShaderSource() " + Type + " : " + FileName, PeekS(*ErrorLog, -1, #PB_Ascii))
        End
      CompilerEndIf
      
      GL20::glDeleteShader(ShaderID)
      FreeMemory(*ErrorLog)
      ShaderID = -1
      
    EndIf
    
    If SHaderBuffer <> #Null
      FreeMemory(ShaderBuffer)
    EndIf
    
    ProcedureReturn ShaderID
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The observators <<<<<

  Procedure.s GetVSFileName(*This.Private_Members)
    
    ProcedureReturn *This\VSFileName
  EndProcedure
  
  Procedure.s GetGSFileName(*This.Private_Members)
    
    ProcedureReturn *This\GSFileName
  EndProcedure
  
  Procedure.s GetFSFileName(*This.Private_Members)
    
    ProcedureReturn *This\FSFileName
  EndProcedure

  Procedure.l GetVertexShaderID(*This.Private_Members)
    
    ProcedureReturn *This\VertexShaderID
  EndProcedure

  Procedure.l GetGeometryShaderID(*This.Private_Members)
    
    ProcedureReturn *This\GeometryShaderID
  EndProcedure
  
  Procedure.l GetFragmentShaderID(*This.Private_Members)
    
    ProcedureReturn *This\FragmentShaderID
  EndProcedure
  
  Procedure.l GetProgramID(*This.Private_Members)
    
    ProcedureReturn *This\ProgramID
  EndProcedure
  
  Procedure.l GetUniforms(*This.Private_Members)
    
    ProcedureReturn *This\Uniforms()
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The mutators <<<<<

  Procedure SetVSFileName(*This.Private_Members, VSFileName.s)
    
    *This\VSFileName = VSFileName
    
  EndProcedure
  
  Procedure SetGSFileName(*This.Private_Members, GSFileName.s)
    
    *This\GSFileName = GSFileName
    
  EndProcedure
  
  Procedure SetFSFileName(*This.Private_Members, FSFileName.s)
    
    *This\FSFileName = FSFileName
    
  EndProcedure
  
  Procedure SetVertexShaderID(*This.Private_Members, VertexShaderID.l)
    
    *This\VertexShaderID = VertexShaderID
    
  EndProcedure
  
  Procedure SetGeometryShaderID(*This.Private_Members, GeometryShaderID.l)
    
    *This\GeometryShaderID = GeometryShaderID
    
  EndProcedure
  
  Procedure SetFragmentShaderID(*This.Private_Members, FragmentShaderID.l)
    
    *This\FragmentShaderID = FragmentShaderID
    
  EndProcedure
  
  Procedure SetProgramID(*This.Private_Members, ProgramID.l)
    
    *This\ProgramID = ProgramID
    
  EndProcedure
  
  Procedure SetUniforms(*This.Private_Members, Uniforms.l)
    
    *This\Uniforms() = Uniforms
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Add to map operator(s) <<<<<

  Procedure AddUniforms(*This.Private_Members, UniformName.s)
    
    AddMapElement(*This\Uniforms(), UniformName)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Clear map operator(s) <<<<<

  Procedure ClearUniforms(*This.Private_Members)
    
    ClearMap(*This\Uniforms())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The map Size operator(s) <<<<<

  Procedure.l UniformsSize(*This.Private_Members)
    
    ProcedureReturn MapSize(*This\Uniforms())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Reset map operator(s) <<<<<

  Procedure ResetUniforms(*This.Private_Members)
    
    ResetMap(*This\Uniforms())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Delete map element operator(s) <<<<<

  Procedure DeleteUniforms(*This.Private_Members)
    
    DeleteMapElement(*This\Uniforms())
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Find map element operator(s) <<<<<

  Procedure.i FindUniforms(*This.Private_Members, UniformName.s)
    
    ProcedureReturn FindMapElement(*This\Uniforms(), UniformName)
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Next map element operator(s) <<<<<

  Procedure.i NextUniforms(*This.Private_Members)
    
    ProcedureReturn NextMapElement(*This\Uniforms())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The map Key operator(s) <<<<<

  Procedure.s UniformsKey(*This.Private_Members)
    
    ProcedureReturn MapKey(*This\Uniforms())
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Compile operator <<<<<
  
  Procedure Compile(*This.Private_Members, SourcePath.s, *RemoteBindAttribute)
    
    VSSource.s = LoadShaderSource(SourcePath + *This\VSFileName)
    *This\VertexShaderID = CompileShaderSource(*This\VSFileName, VSSource, OGL::#GL_VERTEX_SHADER)
    
    If *This\GSFileName <> ""
      GSSource.s = LoadShaderSource(SourcePath + *This\GSFileName)
      *This\GeometryShaderID = CompileShaderSource(*This\GSFileName, GSSource, OGL::#GL_GEOMETRY_SHADER)
    Else
      *This\GeometryShaderID = 0
    EndIf
    
    FSSource.s = LoadShaderSource(SourcePath + *This\FSFileName)
    *This\FragmentShaderID = CompileShaderSource(*This\FSFileName, FSSource, OGL::#GL_FRAGMENT_SHADER)
    
    If *This\VertexShaderID <> -1 And *This\GeometryShaderID = 0 And *This\FragmentShaderID <> -1
      
      *This\ProgramID = GL20::glCreateProgram()
      
      GL20::glAttachShader(*This\ProgramID, *This\VertexShaderID)
      GL20::glAttachShader(*This\ProgramID, *This\FragmentShaderID)
      
      BindAttribute.BindAttribute = *RemoteBindAttribute
      BindAttribute(*This\ProgramID)
      
      GL20::glLinkProgram(*This\ProgramID)
      
      IsProgramLinked.l = 0
      
      GL20::glGetProgramiv(*This\ProgramID, OGL::#GL_LINK_STATUS, @IsProgramLinked)
      
      If IsProgramLinked = #GL_FALSE
        
        MaxLength.l = 0
        GL20::glGetProgramiv(*This\programID, OGL::#GL_INFO_LOG_LENGTH, @MaxLength);
        
        *InfoLog = Ascii(Space(MaxLength)) ; The MaxLength includes the NULL character
        
        GL20::glGetProgramInfoLog(*This\ProgramID, MaxLength, @InfoLogSize.l, *InfoLog);
        
        CompilerIf #PB_Compiler_Debugger
          DebuggerError("ShaderProgram -> Compile() : Program linking failed : " + PeekS(*InfoLog, -1, #PB_Ascii))
        CompilerElse 
          MessageRequester("ShaderProgram -> Compile()", "Program linking failed : " + PeekS(*InfoLog, -1, #PB_Ascii))
          End
        CompilerEndIf
        
        GL20::glDetachShader(*This\ProgramID, *This\VertexShaderID)
        GL20::glDetachShader(*This\ProgramID, *This\FragmentShaderID)
        GL20::glDeleteShader(*This\VertexShaderID)
        GL20::glDeleteShader(*This\FragmentShaderID)
        GL20::glDeleteProgram(*This\ProgramID)
        FreeMemory(*InfoLog)
        *This\ProgramID = -1
        
      EndIf
      
      GL20::glValidateProgram(*This\ProgramID) 
      
      IsProgramValid.l = 0
      GL20::glGetProgramiv(*This\ProgramID, OGL::#GL_VALIDATE_STATUS, @IsProgramValid)
      
      If IsProgramValid = #GL_FALSE
        
        MaxLength.l = 0
        GL20::glGetProgramiv(*This\programID, OGL::#GL_INFO_LOG_LENGTH, @MaxLength);
        
        *InfoLog = Ascii(Space(MaxLength)) ; The MaxLength includes the NULL character
        
        GL20::glGetProgramInfoLog(*This\ProgramID, MaxLength, @InfoLogSize.l, *InfoLog);
        
        CompilerIf #PB_Compiler_Debugger
          DebuggerError("ShaderProgram -> Compile() : Program Invalid : " + PeekS(*InfoLog, -1, #PB_Ascii))
        CompilerElse 
          MessageRequester("ShaderPrograms -> Compile()", "Program Invalid : " + PeekS(*InfoLog, -1, #PB_Ascii))
          End
        CompilerEndIf
        
        GL20::glDetachShader(*This\ProgramID, *This\VertexShaderID)
        GL20::glDetachShader(*This\ProgramID, *This\FragmentShaderID)
        GL20::glDeleteShader(*This\VertexShaderID)
        GL20::glDeleteShader(*This\FragmentShaderID)
        GL20::glDeleteProgram(*This\ProgramID)
        FreeMemory(*InfoLog)
        *This\ProgramID = -1
        
      EndIf
      
    ElseIf  *This\VertexShaderID <> -1 And *This\GeometryShaderID <> -1 And *This\FragmentShaderID <> -1 
      
      *This\ProgramID = GL20::glCreateProgram()
      
      GL20::glAttachShader(*This\ProgramID, *This\VertexShaderID)
      GL20::glAttachShader(*This\ProgramID, *This\GeometryShaderID)
      GL20::glAttachShader(*This\ProgramID, *This\FragmentShaderID)
      
      BindAttribute.BindAttribute = *RemoteBindAttribute
      BindAttribute(*This\ProgramID)
      
      GL20::glLinkProgram(*This\ProgramID)
      
      IsProgramLinked.l = 0
      
      GL20::glGetProgramiv(*This\ProgramID, OGL::#GL_LINK_STATUS, @IsProgramLinked)
      
      If IsProgramLinked = #GL_FALSE
        
        MaxLength.l = 0
        GL20::glGetProgramiv(*This\programID, OGL::#GL_INFO_LOG_LENGTH, @MaxLength);
        
        *InfoLog = Ascii(Space(MaxLength)) ; The MaxLength includes the NULL character
        
        GL20::glGetProgramInfoLog(*This\ProgramID, MaxLength, @InfoLogSize.l, *InfoLog);
        
        CompilerIf #PB_Compiler_Debugger
          DebuggerError("ShaderProgram -> Compile() : Program linking failed : " + PeekS(*InfoLog, -1, #PB_Ascii))
        CompilerElse 
          MessageRequester("ShaderProgram -> Compile()", "Program linking failed : " + PeekS(*InfoLog, -1, #PB_Ascii))
          End
        CompilerEndIf
        
        GL20::glDetachShader(*This\ProgramID, *This\VertexShaderID)
        GL20::glDetachShader(*This\ProgramID, *This\GeometryShaderID)
        GL20::glDetachShader(*This\ProgramID, *This\FragmentShaderID)
        GL20::glDeleteShader(*This\VertexShaderID)
        GL20::glDeleteShader(*This\GeometryShaderID)
        GL20::glDeleteShader(*This\FragmentShaderID)
        GL20::glDeleteProgram(*This\ProgramID)
        FreeMemory(*InfoLog)
        *This\ProgramID = -1
        
      EndIf
      
      GL20::glValidateProgram(*This\ProgramID) 
      
      IsProgramValid.l = 0
      GL20::glGetProgramiv(*This\ProgramID, OGL::#GL_VALIDATE_STATUS, @IsProgramValid)
      
      If IsProgramValid = #GL_FALSE
        
        MaxLength.l = 0
        GL20::glGetProgramiv(*This\programID, OGL::#GL_INFO_LOG_LENGTH, @MaxLength);
        
        *InfoLog = Ascii(Space(MaxLength)) ; The MaxLength includes the NULL character
        
        GL20::glGetProgramInfoLog(*This\ProgramID, MaxLength, @InfoLogSize.l, *InfoLog);
        
        CompilerIf #PB_Compiler_Debugger
          DebuggerError("ShaderProgram -> Compile() : Program Invalid : " + PeekS(*InfoLog, -1, #PB_Ascii))
        CompilerElse 
          MessageRequester("ShaderPrograms -> Compile()", "Program Invalid : " + PeekS(*InfoLog, -1, #PB_Ascii))
          End
        CompilerEndIf
        
        GL20::glDetachShader(*This\ProgramID, *This\VertexShaderID)
        GL20::glDetachShader(*This\ProgramID, *This\GeometryShaderID)
        GL20::glDetachShader(*This\ProgramID, *This\FragmentShaderID)
        GL20::glDeleteShader(*This\VertexShaderID)
        GL20::glDeleteShader(*This\GeometryShaderID)
        GL20::glDeleteShader(*This\FragmentShaderID)
        GL20::glDeleteProgram(*This\ProgramID)
        FreeMemory(*InfoLog)
        *This\ProgramID = -1
        
      EndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The GetUniformLocations operator <<<<<
  
  Procedure GetUniformLocations(*This.Private_Members)
    
    ForEach *This\Uniforms()
      
      UniformName.s = MapKey(*This\Uniforms())
      
      UniformLocation = GL20::glGetUniformLocation(*This\ProgramID, UniformName)
      
      If UniformLocation <> -1
        *This\Uniforms() = UniformLocation
      Else
        
        CompilerIf #PB_Compiler_Debugger
          DebuggerError("ShaderProgram -> GetUniformLocations() : Impossible to find the uniform " + UniformName)
        CompilerElse 
          MessageRequester("ShaderProgram -> GetUniformLocations()", "Impossible to find the Uniform : " + UniformName)
          End
        CompilerEndIf
        
      EndIf
    Next
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniformMatrix4fv operator <<<<<
  
  Procedure SendUniformMatrix4fv(*This.Private_Members, UniformName.s, *MatrixA.Matrix44f::Matrix44f)

    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniformMatrix4fv(*This\Uniforms(), 1, #GL_FALSE, *MatrixA\Access())
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniformMatrix4fv() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniformMatrix4fv()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniformVector3fv operator <<<<<
  
  Procedure SendUniformVector3fv(*This.Private_Members, UniformName.s, *VectorA.Vector3f::Vector3f)
    
    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniform3fv(*This\Uniforms(), 1, *VectorA\Access())
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniformVector3fv() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniformVector3fv()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniformVector2fv operator <<<<<
  
  Procedure SendUniformVector2fv(*This.Private_Members, UniformName.s, *VectorA.Vector2f::Vector2f)
    
    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniform2fv(*This\Uniforms(), 1, *VectorA\Access())
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniformVector2fv() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniformVector2fv()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniformColor3fv operator <<<<<
  
  Procedure SendUniformColor3fv(*This.Private_Members, UniformName.s, *ColorA.Color3f::Color3f)
    
    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniform3fv(*This\Uniforms(), 1, *ColorA\Access())
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniformColor3fv() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniformColor3fv()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniformColor4fv operator <<<<<
  
  Procedure SendUniformColor4fv(*This.Private_Members, UniformName.s, *ColorA.Color4f::Color4f)
    
    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniform4fv(*This\Uniforms(), 1, *ColorA\Access())
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniformColor4fv() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniformColor4fv()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniform1i operator <<<<<
  
  Procedure SendUniform1i(*This.Private_Members, UniformName.s, Integer.l)
    
    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniform1i(*This\Uniforms(), Integer)
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniform1i() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniform1i()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SendUniform1f operator <<<<<
  
  Procedure SendUniform1f(*This.Private_Members, UniformName.s, Float.f)
    
    If FindMapElement(*This\Uniforms(), UniformName)
      GL20::glUniform1f(*This\Uniforms(), Float)
    Else
      
      CompilerIf #PB_Compiler_Debugger
        DebuggerError("ShaderProgram -> SendUniform1f() : Impossible to find the uniform " + UniformName)
      CompilerElse 
        MessageRequester("ShaderProgram -> SendUniform1f()", "Impossible to find the Uniform : " + UniformName)
        End
      CompilerEndIf
      
    EndIf
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    GL20::glDetachShader(*This\ProgramID, *This\VertexShaderID)
    
    If *This\GeometryShaderID <> 0
      GL20::glDetachShader(*This\ProgramID, *This\GeometryShaderID)
    EndIf
    
    GL20::glDetachShader(*This\ProgramID, *This\FragmentShaderID)
    
    GL20::glDeleteShader(*This\VertexShaderID)
    
    If *This\GeometryShaderID <> 0
      GL20::glDeleteShader(*This\GeometryShaderID)
    EndIf
    
    GL20::glDeleteShader(*This\FragmentShaderID)
    GL20::glDeleteProgram(*This\ProgramID)

    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructor <<<<<
  
  Procedure.i New(VSFileName.s, GSFileName.s, FSFileName.s)
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    *This\VSFileName = VSFileName
    *This\GSFileName = GSFileName
    *This\FSFileName = FSFileName
    
    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetVSFileName()
    Data.i @GetGSFileName()
    Data.i @GetFSFileName()
    Data.i @GetVertexShaderID()
    Data.i @GetGeometryShaderID()
    Data.i @GetFragmentShaderID()
    Data.i @GetProgramID()
    Data.i @GetUniforms()
    Data.i @SetVSFileName()
    Data.i @SetGSFileName()
    Data.i @SetFSFileName()
    Data.i @SetVertexShaderID()
    Data.i @SetGeometryShaderID()
    Data.i @SetFragmentShaderID()
    Data.i @SetProgramID()
    Data.i @SetUniforms()
    Data.i @AddUniforms()
    Data.i @ClearUniforms()
    Data.i @UniformsSize()
    Data.i @ResetUniforms()
    Data.i @DeleteUniforms()
    Data.i @FindUniforms()
    Data.i @NextUniforms()
    Data.i @UniformsKey()
    Data.i @Compile()
    Data.i @GetUniformLocations()
    Data.i @SendUniformMatrix4fv()
    Data.i @SendUniformVector3fv()
    Data.i @SendUniformVector2fv()
    Data.i @SendUniformColor3fv()
    Data.i @SendUniformColor4fv()
    Data.i @SendUniform1i()
    Data.i @SendUniform1f()
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (158000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.00 LTS (Linux - x64)
; Folding = --------4-
; EnableXP
; CompileSourceDirectory