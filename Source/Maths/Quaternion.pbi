; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; AUTOMATICALLY GENERATED CODE, DO NOT MODIFY
; UNLESS YOU REALLY, REALLY, REALLY MEAN IT !!
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; Code generated by : Dev-Object - V2.0.0 Beta 7
; Project name : OpenGL 3D Game Tutorial
; File name : Quaternion.pbi
; File Version : 1.0.0
; Programmation : OK
; Programmed by : Guillaume Saumure
; AKA : StarBootics
; E-mail : gsaumure@cgocable.ca
; Creation Date : November 10th, 2021
; Last update : July 21st, 2022
; Coded for PureBasic : V6.00 LTS
; Platform : Windows, Linux, MacOS X
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; The MIT License (MIT)
; 
; Copyright (c) 2021 Guillaume Saumure
; 
; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and 
; associated documentation files (the "Software"), to deal in the Software without restriction, including 
; without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
; copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the 
; following conditions:
; 
; The above copyright notice and this permission notice shall be included in all copies or substantial 
; portions of the Software.
; 
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT 
; LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO 
; EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER 
; IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
; THE USE OR OTHER DEALINGS IN THE SOFTWARE.
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

DeclareModule Quaternion
  
  Interface Quaternion
    GetS.f()
    GetI.f()
    GetJ.f()
    GetK.f()
    SetS(s.f)
    SetI(i.f)
    SetJ(j.f)
    SetK(k.f)
    Update(s.f, i.f, j.f, k.f)
    Clear()
    Equal(*Other)
    Plus.i(*Other)
    Minus.i(*Other)
    Add(*Other)
    Substract(*Other)
    Product.i(*Other)
    Multiply(*Other)
    ProductByScalar(Scalar.f)
    DivideByScalar(Scalar.f)
    AddScaledVector(*Vector.Vector3f::Vector3f, Scale.f)
    Copy.i()
    Compare.i(*Other)
    Swapping(*Other)
    Conjugate.i()
    Modulus.f()
    SquareModulus.f()
    Invert.i()
    Divide.i(*Other)
    Normalize()
    DirectRotation(*NewPoint.Vector3f::Vector3f, *Point.Vector3f::Vector3f)
    DirectRotationTranslation(*Translation.Vector3f::Vector3f, *NewPoint.Vector3f::Vector3f, *Point.Vector3f::Vector3f)
    Lerp.i(*Other, t.f)
    Slerp.i(*Other, t.f)
    GetForward.i()
    GetBack.i()
    GetUp.i()
    GetDown.i()
    GetRight.i()
    GetLeft.i()
    Format.s(Decimal.b = 3, Brackets.s = "[]", Separator.s = ", ")
    FromAxisAngle(*Axis.Vector3f::Vector3f, Angle.f)
    
    CompilerIf Defined(Matrix44f, #PB_Module)
      ToRotationMatrix.i()
      FromRotationMatrix(*Rotation.Matrix44f::Matrix44f)
    CompilerEndIf  
    
    FromAngles(*Angles.Vector3f::Vector3f)
    Free()
    
  EndInterface

  Declare.i New(s.f = 1.0, i.f = 0.0, j.f = 0.0, k.f = 0.0)
  Declare.i NewFromAxisAngle(*Axis.Vector3f::Vector3f, Angle.f)
  
  CompilerIf Defined(Matrix44f, #PB_Module)
    Declare.i NewFromMatrix(*Rotation.Matrix44f::Matrix44f)
  CompilerEndIf
  
  Declare.i NewFromVectors(*V1.Vector3f::Vector3f, *V2.Vector3f::Vector3f)
  Declare.i NewFromAngles(*Angles.Vector3f::Vector3f)
  
EndDeclareModule

Module Quaternion
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< Structure declaration <<<<<
  
  Structure Private_Members

    VirtualTable.i
    s.f
    i.f
    j.f
    k.f
    
  EndStructure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The observators <<<<<
  
  Procedure.f GetS(*This.Private_Members)
    
    ProcedureReturn *This\s
  EndProcedure

  Procedure.f GetI(*This.Private_Members)

    ProcedureReturn *This\i
  EndProcedure

  Procedure.f GetJ(*This.Private_Members)

    ProcedureReturn *This\j
  EndProcedure

  Procedure.f GetK(*This.Private_Members)

    ProcedureReturn *This\k
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The mutators <<<<<
  
  Procedure SetS(*This.Private_Members, s.f)

    *This\s = s

  EndProcedure

  Procedure SetI(*This.Private_Members, i.f)

    *This\i = i

  EndProcedure

  Procedure SetJ(*This.Private_Members, j.f)

    *This\j = j

  EndProcedure

  Procedure SetK(*This.Private_Members, k.f)

    *This\k = k

  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Update operator <<<<<
  
  Procedure Update(*This.Private_Members, s.f, i.f, j.f, k.f)

    *This\s = s
    *This\i = i
    *This\j = j
    *This\k = k

  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Clear operator <<<<<
  
  Procedure Clear(*This.Private_Members)

    *This\s = 0.0
    *This\i = 0.0
    *This\j = 0.0
    *This\k = 0.0
   
  EndProcedure

  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Equal operator : A = B <<<<<

  Procedure Equal(*This.Private_Members, *Other.Private_Members)
    
    *This\s = *Other\s
    *This\i = *Other\i
    *This\j = *Other\j
    *This\k = *Other\k
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Plus operator : R = A + B <<<<<

  Procedure.i Plus(*This.Private_Members, *Other.Private_Members)
    
    *Result.Private_Members = AllocateStructure(Private_Members)
    *Result\VirtualTable = ?START_METHODS
    
    *Result\s = *This\s + *Other\s
    *Result\i = *This\i + *Other\i
    *Result\j = *This\j + *Other\j
    *Result\k = *This\k + *Other\k
    
    ProcedureReturn *Result
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Minus operator : R = A + B <<<<<

  Procedure.i Minus(*This.Private_Members, *Other.Private_Members)
    
    *Result.Private_Members = AllocateStructure(Private_Members)
    *Result\VirtualTable = ?START_METHODS
    
    *Result\s = *This\s - *Other\s
    *Result\i = *This\i - *Other\i
    *Result\j = *This\j - *Other\j
    *Result\k = *This\k - *Other\k
    
    ProcedureReturn *Result
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Add operator : A = A + B <<<<<

  Procedure Add(*This.Private_Members, *Other.Private_Members)
    
    *This\s + *Other\s
    *This\i + *Other\i
    *This\j + *Other\j
    *This\k + *Other\k
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Subtract operator : A = A - B <<<<<

  Procedure Substract(*This.Private_Members, *Other.Private_Members)
    
    *This\s - *Other\s
    *This\i - *Other\i
    *This\j - *Other\j
    *This\k - *Other\k
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Product operator : R = A + B <<<<<
  
  Procedure.i Product(*This.Private_Members, *Other.Private_Members)
    
    *Result.Private_Members = AllocateStructure(Private_Members)
    *Result\VirtualTable = ?START_METHODS
    
		*Result\s = *This\s * *Other\s - *This\i * *Other\i - *This\j * *Other\j - *This\k * *Other\k
		*Result\i = *This\i * *Other\s + *This\s * *Other\i + *This\j * *Other\k - *This\k * *Other\j
		*Result\j = *This\j * *Other\s + *This\s * *Other\j + *This\k * *Other\i - *This\i * *Other\k
		*Result\k = *This\k * *Other\s + *This\s * *Other\k + *This\i * *Other\j - *This\j * *Other\i
		
    ProcedureReturn *Result
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Multiply operator : R = A + B <<<<<
  
  Procedure Multiply(*This.Private_Members, *Other.Private_Members)

		s.f = *This\s * *Other\s - *This\i * *Other\i - *This\j * *Other\j - *This\k * *Other\k
		i.f = *This\i * *Other\s + *This\s * *Other\i + *This\j * *Other\k - *This\k * *Other\j
		j.f = *This\j * *Other\s + *This\s * *Other\j + *This\k * *Other\i - *This\i * *Other\k
		k.f = *This\k * *Other\s + *This\s * *Other\k + *This\i * *Other\j - *This\j * *Other\i
		
		*This\s = s
		*This\i = i		
		*This\j = j
		*This\k = k
		
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The ProductByScalar operator : A = A * Scalar <<<<<
  
  Procedure ProductByScalar(*This.Private_Members, Scalar.f)

    *This\s * Scalar
    *This\i * Scalar
    *This\j * Scalar
    *This\k * Scalar

  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The DivideByScalar operator : A = A / Scalar <<<<<
  
  Procedure DivideByScalar(*This.Private_Members, Scalar.f)

    *This\s / Scalar
    *This\i / Scalar
    *This\j / Scalar
    *This\k / Scalar

  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The AddScaledVector operator <<<<<
  
  Procedure AddScaledVector(*This.Private_Members, *Vector.Vector3f::Vector3f, Scale.f)
    
    Protected Temp0.Private_Members, Temp1.Private_Members
    
    Temp0\s = 0.0
    Temp0\i = *Vector\GetI() * Scale
    Temp0\j = *Vector\GetJ() * Scale
    Temp0\k = *Vector\GetK() * Scale
    
    Temp1\s = Temp0\s * *This\s - Temp0\i * *This\i - Temp0\j * *This\j - Temp0\k * *This\k
		Temp1\i = Temp0\i * *This\s + Temp0\s * *This\i + Temp0\j * *This\k - Temp0\k * *This\j
		Temp1\j = Temp0\j * *This\s + Temp0\s * *This\j + Temp0\k * *This\i - Temp0\i * *This\k
		Temp1\k = Temp0\k * *This\s + Temp0\s * *This\k + Temp0\i * *This\j - Temp0\j * *This\i

    *This\s + Temp1\s * 0.5
    *This\i + Temp1\i * 0.5
    *This\j + Temp1\j * 0.5
    *This\k + Temp1\k * 0.5
    
  EndProcedure
 
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Copy operator <<<<<

  Procedure.i Copy(*This.Private_Members)
    
    *Copy.Private_Members = AllocateStructure(Private_Members)
    
    CopyMemory(*This, *Copy, SizeOf(Private_Members))
    
    ProcedureReturn *Copy
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Compare operator <<<<<

  Procedure.i Compare(*This.Private_Members, *Other.Private_Members)
    
    ProcedureReturn CompareMemory(*This, *Other, SizeOf(Private_Members))
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Swapping operator <<<<<

  Procedure Swapping(*This.Private_Members, *Other.Private_Members)
    
    Swap *This\s, *Other\s
    Swap *This\i, *Other\i
    Swap *This\j, *Other\j
    Swap *This\k, *Other\k
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Conjugate operator <<<<<
  
  Procedure.i Conjugate(*This.Private_Members)
    
    ProcedureReturn New(*This\s, -*This\i, -*This\j, -*This\k)
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Modulus operator <<<<<
  
  Procedure.f Modulus(*This.Private_Members)
    
    ProcedureReturn Sqr(*This\s * *This\s + *This\i * *This\i + *This\j * *This\j + *This\k * *This\k)
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The SquareModulus operator <<<<<
  
  Procedure.f SquareModulus(*This.Private_Members)
    
    ProcedureReturn *This\s * *This\s + *This\i * *This\i + *This\j * *This\j + *This\k * *This\k
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Invert operator <<<<<
  
  Procedure.i Invert(*This.Private_Members)
    
    Square_Quaternion_Modulus.d = SquareModulus(*This)
    
    If Square_Quaternion_Modulus <> 0.0
      s.f = *This\s / Square_Quaternion_Modulus
      i.f = *This\i / -Square_Quaternion_Modulus
      j.f = *This\j / -Square_Quaternion_Modulus
      k.f = *This\k / -Square_Quaternion_Modulus
    Else
      s.f = 1.0
      i.f = 0.0
      j.f = 0.0
      k.f = 0.0
    EndIf 
    
    ProcedureReturn New(s, i, j, k)
  EndProcedure 
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Divide operator <<<<<
  
  Procedure.i Divide(*This.Private_Members, *Other.Private_Members)
    
    *Copy.Private_Members = Invert(*Other)
    *Divided = Product(*Copy, *This)
   
    FreeStructure(*Copy)
    
    ProcedureReturn *Divided
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Normalize operator <<<<<
  
  Procedure Normalize(*This.Private_Members)
    
    Normalize_Quaternion_Modulus.f = Modulus(*This)
    
    If Normalize_Quaternion_Modulus = 0.0
      *This\s = 1.0
      *This\i = 0.0
      *This\j = 0.0
      *This\k = 0.0
    Else
      *This\s / Normalize_Quaternion_Modulus
      *This\i / Normalize_Quaternion_Modulus
      *This\j / Normalize_Quaternion_Modulus
      *This\k / Normalize_Quaternion_Modulus
    EndIf 
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The DirectRotation operator <<<<<
  
  Procedure DirectRotation(*This.Private_Members, *NewPoint.Vector3f::Vector3f, *Point.Vector3f::Vector3f)
    
    Copy.Vector3f::Vector3f = *Point\Copy()
    
    t1.f = *This\s * *This\i
    t2.f = *This\s * *This\j
    t3.f = *This\s * *This\k
    t4.f = -*This\i * *This\i
    t5.f = *This\i * *This\j
    t6.f = *This\i * *This\k
    t7.f = -*This\j * *This\j
    t8.f = *This\j * *This\k
    t9.f = -*This\k * *This\k
    
    *NewPoint\SetI(2 * ((t7 + t9) * Copy\GetI() + (t5 - t3) * Copy\GetJ() + (t2 + t6) * Copy\GetK()) + Copy\GetI())
    *NewPoint\SetJ(2 * ((t3 + t5) * Copy\GetI() + (t4 + t9) * Copy\GetJ() + (t8 - t1) * Copy\GetK()) + Copy\GetJ())
    *NewPoint\SetK(2 * ((t6 - t2) * Copy\GetI() + (t1 + t8) * Copy\GetJ() + (t4 + t7) * Copy\GetK()) + Copy\GetK())
    
    Copy\Free()
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The DirectRotationTranslation operator <<<<<
  
  Procedure DirectRotationTranslation(*This.Private_Members, *Translation.Vector3f::Vector3f, *NewPoint.Vector3f::Vector3f, *Point.Vector3f::Vector3f)
    
    Copy.Vector3f::Vector3f = *Point\Copy()
    
    t1.f = *This\s * *This\i
    t2.f = *This\s * *This\j
    t3.f = *This\s * *This\k
    t4.f = -*This\i * *This\i
    t5.f = *This\i * *This\j
    t6.f = *This\i * *This\k
    t7.f = -*This\j * *This\j
    t8.f = *This\j * *This\k
    t9.f = -*This\k * *This\k
    
    *NewPoint\SetI(2 * ((t7 + t9) * Copy\GetI() + (t5 - t3) * Copy\GetJ() + (t2 + t6) * Copy\GetK()) + Copy\GetI() + *Translation\GetI())
    *NewPoint\SetJ(2 * ((t3 + t5) * Copy\GetI() + (t4 + t9) * Copy\GetJ() + (t8 - t1) * Copy\GetK()) + Copy\GetJ() + *Translation\GetJ())
    *NewPoint\SetK(2 * ((t6 - t2) * Copy\GetI() + (t1 + t8) * Copy\GetJ() + (t4 + t7) * Copy\GetK()) + Copy\GetK() + *Translation\GetK())
    
    Copy\Free()
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Linear Interpolation operator <<<<<
  
  Procedure.i Lerp(*This.Private_Members, *Other.Private_Members, t.f)
    
    One_Minus_t.f = 1.0 - t
    
    s.f = *This\s * One_Minus_t + *Other\s * t
    i.f = *This\i * One_Minus_t + *Other\i * t
    j.f = *This\j * One_Minus_t + *Other\j * t
    k.f = *This\k * One_Minus_t + *Other\k * t
    
    *Calculated.Private_Members = New(s, i, j, k)
    Normalize(*Calculated)
    
    ProcedureReturn *Calculated
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Spherical Interpolation operator <<<<<
  
  Procedure.i Slerp(*This.Private_Members, *Other.Private_Members, t.f)
    
    One_Minus_t.f = 1.0 - t
    Dot.f = *This\i * *Other\i + *This\j * *Other\j + *This\k * *Other\k + *This\s * *Other\s
    
    If Dot > 0.9995 ; We are too close, so we do a linear interpolation instead
      s.f = *This\s * One_Minus_t + *Other\s * t
      i.f = *This\i * One_Minus_t + *Other\i * t
      j.f = *This\j * One_Minus_t + *Other\j * t
      k.f = *This\k * One_Minus_t + *Other\k * t
    Else
      Theta.f = ACos(Dot)
      Sin_Theta.f = Sin(Theta)
      Wa.f = Sin(One_Minus_t * Theta) / Sin_Theta
      Wb.f = Sin(t * Theta) / Sin_Theta
      s.f = *This\s * Wa + *Other\s * Wb
      i.f = *This\i * Wa + *Other\i * Wb
      j.f = *This\j * Wa + *Other\j * Wb
      k.f = *This\k * Wa + *Other\k * Wb
    EndIf
    
    *Calculated.Private_Members = New(s, i, j, k)
    Normalize(*Calculated)
    
    ProcedureReturn *Calculated
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Additionnal Observators <<<<<
  
  Procedure.i GetForward(*This.Private_Members)
    
    *Forward.Vector3f::Vector3f = Vector3f::New(0.0, 0.0, 1.0)
    DirectRotation(*This, *Forward, *Forward)
    *Forward\Normalize()
    
    ProcedureReturn *Forward
  EndProcedure
  
  Procedure.i GetBack(*This.Private_Members)
    
    *Back.Vector3f::Vector3f = Vector3f::New(0.0, 0.0, -1.0)
    DirectRotation(*This, *Back, *Back)
    *Back\Normalize()
    
    ProcedureReturn *Back
  EndProcedure
  
  Procedure.i GetUp(*This.Private_Members)
    
    *Up.Vector3f::Vector3f = Vector3f::New(0.0, 1.0, 0.0)
    DirectRotation(*This, *Up, *Up)
    *Up\Normalize()
    
    ProcedureReturn *Up
  EndProcedure
  
  Procedure.i GetDown(*This.Private_Members)
    
    *Down.Vector3f::Vector3f = Vector3f::New(0.0, -1.0, 0.0)
    DirectRotation(*This, *Down, *Down)
    *Down\Normalize()
    
    ProcedureReturn *Down
  EndProcedure
  
  Procedure.i GetRight(*This.Private_Members)
    
    *Right.Vector3f::Vector3f = Vector3f::New(1.0, 0.0, 0.0)
    DirectRotation(*This, *Right, *Right)
    *Right\Normalize()
    
    ProcedureReturn *Right
  EndProcedure
  
  Procedure.i GetLeft(*This.Private_Members)
    
    *Left.Vector3f::Vector3f = Vector3f::New(-1.0, 0.0, 0.0)
    DirectRotation(*This, *Left, *Left)
    *Left\Normalize()
    
    ProcedureReturn *Left
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Format operator <<<<<
  
  Procedure.s Format(*This.Private_Members, Decimal.b = 3, Brackets.s = "[]", Separator.s = ", ")
    
    ProcedureReturn Mid(Brackets, 1, 1) + StrF(*This\s, Decimal) +  Separator + StrF(*This\i, Decimal) + Separator + StrF(*This\j, Decimal) + Separator + StrF(*This\k, Decimal) + Mid(Brackets, 2, 1)
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The FromAxisAngle operator <<<<<
  
  Procedure FromAxisAngle(*This.Private_Members, *Axis.Vector3f::Vector3f, Angle.f)
    
    Protected HalfAngle.f, CosHalfAngle.f, SinHalfAngle.f
    
    HalfAngle = Angle * 0.5
    
    CosHalfAngle = Cos(HalfAngle)
    SinHalfAngle = Sin(HalfAngle)
    
    *This\s = CosHalfAngle
    *This\i = *Axis\GetI() * SinHalfAngle
    *This\j = *Axis\GetJ() * SinHalfAngle
    *This\k = *Axis\GetK() * SinHalfAngle
    
    Normalize(*This)
    
  EndProcedure 
  
  CompilerIf Defined(Matrix44f, #PB_Module)
    
    ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ; <<<<< The ToRotationMatrix operator <<<<<
    
    Procedure.i ToRotationMatrix(*This.Private_Members)
      
      *Rotation.Matrix44f::Matrix44f = Matrix44f::New()
      
      Forward.Vector3f::Vector3f = Vector3f::New()
      Forward\SetI(2.0 * (*This\i * *This\k - *This\s * *This\j))
      Forward\SetJ(2.0 * (*This\j * *This\k + *This\s * *This\i))
      Forward\SetK(1.0 - 2.0 * (*This\i * *This\i + *This\j * *This\j))
      
      Up.Vector3f::Vector3f = Vector3f::New()
      Up\SetI(2.0 * (*This\i * *This\j + *This\s * *This\k))
      Up\SetJ(1.0 - 2.0 * (*This\i * *This\i + *This\k * *This\k))  
      Up\SetK(2.0 * (*This\j * *This\k - *This\s * *This\i))
      
      Right.Vector3f::Vector3f = Vector3f::New()
      Right\SetI(1.0 - 2.0 * (*This\j * *This\j + *This\k * *This\k))
      Right\SetJ(2.0 * (*This\i * *This\j - *This\s * *This\k))
      Right\SetK(2.0 * (*This\i * *This\k + *This\s * *This\j))
      
      *Rotation\Rotation(Forward, Up, Right)
      Forward\Free()
      Up\Free()
      Right\Free()
      
      ProcedureReturn *Rotation
    EndProcedure
    
    ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
    ; <<<<< The FromRotationMatrix operator <<<<<
    
    Procedure FromRotationMatrix(*This.Private_Members, *Rotation.Matrix44f::Matrix44f)
      
      ; From Ken Shoemake's "Quaternion Calculus and Fast Animation" article
      
      Trace.f = *Rotation\GetE11() + *Rotation\GetE22() + *Rotation\GetE33()
      
      If Trace > 0.0
        s.f = 0.5 / Sqr(Trace + 1.0)
        *This\s = 0.25 / s   
        *This\i = (*Rotation\GetE23() - *Rotation\GetE32()) * s
        *This\j = (*Rotation\GetE31() - *Rotation\GetE13()) * s
        *This\k = (*Rotation\GetE12() - *Rotation\GetE21()) * s
      Else
        If *Rotation\GetE11() > *Rotation\GetE22() And *Rotation\GetE11() > *Rotation\GetE33() 
          s = 2.0 * Sqr(1.0 + *Rotation\GetE11() - *Rotation\GetE22() - *Rotation\GetE33())
          *This\s = (*Rotation\GetE23() - *Rotation\GetE32()) / s     
          *This\i = 0.25 * s                                          
          *This\j = (*Rotation\GetE21() + *Rotation\GetE12()) / s 
          *This\k = (*Rotation\GetE31() + *Rotation\GetE13()) / s
        ElseIf *Rotation\GetE22() > *Rotation\GetE33()             
          s = 2.0 * Sqr(1.0 + *Rotation\GetE22() - *Rotation\GetE11() - *Rotation\GetE33()) ; OK
          *This\s = (*Rotation\GetE31() - *Rotation\GetE13()) / s     
          *This\i = (*Rotation\GetE21() + *Rotation\GetE12()) / s                    
          *This\j = 0.25 * s                                          
          *This\k = (*Rotation\GetE32() + *Rotation\GetE23()) / s
        Else
          s = 2.0 * Sqr(1.0 + *Rotation\GetE33() - *Rotation\GetE22() - *Rotation\GetE11())
          *This\s = (*Rotation\GetE12() - *Rotation\GetE21()) / s     
          *This\i = (*Rotation\GetE31() + *Rotation\GetE13()) / s    
          *This\j = (*Rotation\GetE23() + *Rotation\GetE32()) / s    
          *This\k = 0.25 * s                                      
        EndIf
      EndIf
      
      Normalize(*This)
      
    EndProcedure
    
  CompilerEndIf
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The FromAngles operator <<<<<
  
  Procedure FromAngles(*This.Private_Members, *Angles.Vector3f::Vector3f)
    
    *This\s = 1.0
    *This\i = 0.0
    *This\j = 0.0
    *This\k = 0.0
    
    XAxis.Vector3f::Vector3f = Vector3f::New(1.0, 0.0, 0.0)
    YAxis.Vector3f::Vector3f = Vector3f::New(0.0, 1.0, 0.0)
    ZAxis.Vector3f::Vector3f = Vector3f::New(0.0, 0.0, 1.0)
    
    *Qx.Private_Members = NewFromAxisAngle(XAxis, *Angles\GetI())
    *Qy.Private_Members = NewFromAxisAngle(YAxis, *Angles\GetJ())
    *Qz.Private_Members = NewFromAxisAngle(ZAxis, *Angles\GetK())
    
    Multiply(*This, *Qz)
    Multiply(*This, *Qy)
    Multiply(*This, *Qx)
    
    XAxis\Free()
    YAxis\Free()
    ZAxis\Free()
    FreeStructure(*Qx)
    FreeStructure(*Qy)
    FreeStructure(*Qz)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Destructor <<<<<

  Procedure Free(*This.Private_Members)
    
    FreeStructure(*This)
    
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Constructors <<<<<
  
  Procedure.i New(s.f = 1.0, i.f = 0.0, j.f = 0.0, k.f = 0.0)

    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    *This\s = s
    *This\i = i
    *This\j = j
    *This\k = k
    
    ProcedureReturn *This
  EndProcedure
  
  Procedure.i NewFromAxisAngle(*Axis.Vector3f::Vector3f, Angle.f)
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    FromAxisAngle(*This, *Axis, Angle)
    
    ProcedureReturn *This
  EndProcedure 
  
  CompilerIf Defined(Matrix44f, #PB_Module)
    
    Procedure.i NewFromMatrix(*Rotation.Matrix44f::Matrix44f)
      
      *This.Private_Members = AllocateStructure(Private_Members)
      *This\VirtualTable = ?START_METHODS
      
      ; From Ken Shoemake's "Quaternion Calculus and Fast Animation" article
      
      Trace.f = *Rotation\GetE11() + *Rotation\GetE22() + *Rotation\GetE33()
      
      If Trace > 0.0
        s.f = 0.5 / Sqr(Trace + 1.0)
        *This\s = 0.25 / s   
        *This\i = (*Rotation\GetE23() - *Rotation\GetE32()) * s
        *This\j = (*Rotation\GetE31() - *Rotation\GetE13()) * s
        *This\k = (*Rotation\GetE12() - *Rotation\GetE21()) * s
      Else
        If *Rotation\GetE11() > *Rotation\GetE22() And *Rotation\GetE11() > *Rotation\GetE33() 
          s = 2.0 * Sqr(1.0 + *Rotation\GetE11() - *Rotation\GetE22() - *Rotation\GetE33())
          *This\s = (*Rotation\GetE23() - *Rotation\GetE32()) / s     
          *This\i = 0.25 * s                                          
          *This\j = (*Rotation\GetE21() + *Rotation\GetE12()) / s 
          *This\k = (*Rotation\GetE31() + *Rotation\GetE13()) / s
        ElseIf *Rotation\GetE22() > *Rotation\GetE33()             
          s = 2.0 * Sqr(1.0 + *Rotation\GetE22() - *Rotation\GetE11() - *Rotation\GetE33())
          *This\s = (*Rotation\GetE31() - *Rotation\GetE13()) / s     
          *This\i = (*Rotation\GetE21() + *Rotation\GetE12()) / s                    
          *This\j = 0.25 * s                                          
          *This\k = (*Rotation\GetE32() + *Rotation\GetE23()) / s
        Else
          s = 2.0 * Sqr(1.0 + *Rotation\GetE33() - *Rotation\GetE22() - *Rotation\GetE11())
          *This\s = (*Rotation\GetE12() - *Rotation\GetE21()) / s     
          *This\i = (*Rotation\GetE31() + *Rotation\GetE13()) / s    
          *This\j = (*Rotation\GetE23() + *Rotation\GetE32()) / s    
          *This\k = 0.25 * s                                      
        EndIf
      EndIf
      
      Normalize(*This)
      
      ProcedureReturn *This
    EndProcedure
    
  CompilerEndIf

  Procedure.i NewFromVectors(*V1.Vector3f::Vector3f, *V2.Vector3f::Vector3f)
    
    Epsilon.f = 0.001
    RV2.Vector3f::Vector3f = *V2\Copy()
    RV2\ProductByScalar(-1.0)
    
    If *V1\CompareEx(*V2, Epsilon)
      RV2\Free()
      ProcedureReturn NewFromAxisAngle(*V1, 0.0)
    ElseIf *V1\CompareEx(RV2, Epsilon)
      
      If *V1\GetI() > -Epsilon And *V1\GetI() < Epsilon
        Axis.Vector3f::Vector3f = Vector3f::New(1.0, 0.0, 0.0)
      ElseIf *V1\GetJ() > -Epsilon And *V1\GetJ() < Epsilon
        Axis.Vector3f::Vector3f = Vector3f::New(0.0, 1.0, 0.0)
      ElseIf *V1\GetK() > -Epsilon And *V1\GetK() < Epsilon
        Axis.Vector3f::Vector3f = Vector3f::New(0.0, 0.0, 1.0)
      EndIf
      
      *Quaternion = NewFromAxisAngle(Axis, #PI/2.0)
      Axis\Free()
      RV2\Free()
      
      ProcedureReturn *Quaternion
      
    EndIf
    
    U1.Vector3f::Vector3f = *V1\Copy()
    U2.Vector3f::Vector3f = *V2\Copy()
    U1\Normalize()
    U2\Normalize()
    Axis.Vector3f::Vector3f = U1\Cross(U2)
    Axis\Normalize()
    
    *Quaternion = NewFromAxisAngle(Axis, ACos(U1\Dot(U2)))
    Axis\Free()
    RV2\Free()
    U1\Free()
    U2\Free()
    
    ProcedureReturn *Quaternion
  EndProcedure
  
  Procedure.i NewFromAngles(*Angles.Vector3f::Vector3f)
    
    *This.Private_Members = AllocateStructure(Private_Members)
    *This\VirtualTable = ?START_METHODS
    
    FromAngles(*This, *Angles)

    ProcedureReturn *This
  EndProcedure
  
  ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
  ; <<<<< The Virtual Table Entries <<<<<

  DataSection
    START_METHODS:
    Data.i @GetS()
    Data.i @GetI()
    Data.i @GetJ()
    Data.i @GetK()
    Data.i @SetS()
    Data.i @SetI()
    Data.i @SetJ()
    Data.i @SetK()
    Data.i @Update()
    Data.i @Clear()
    Data.i @Equal()
    Data.i @Plus()
    Data.i @Minus()
    Data.i @Add()
    Data.i @Substract()
    Data.i @Product()
    Data.i @Multiply()
    Data.i @ProductByScalar()
    Data.i @DivideByScalar()
    Data.i @AddScaledVector()
    Data.i @Copy()
    Data.i @Compare()
    Data.i @Swapping()
    Data.i @Conjugate()
    Data.i @Modulus()
    Data.i @SquareModulus()
    Data.i @Invert()
    Data.i @Divide()
    Data.i @Normalize()
    Data.i @DirectRotation()
    Data.i @DirectRotationTranslation()
    Data.i @Lerp()
    Data.i @Slerp()
    Data.i @GetForward()
    Data.i @GetBack()
    Data.i @GetUp()
    Data.i @GetDown()
    Data.i @GetRight()
    Data.i @GetLeft()
    Data.i @Format()
    Data.i @FromAxisAngle()
    
    CompilerIf Defined(Matrix44f, #PB_Module)
      Data.i @ToRotationMatrix()
      Data.i @FromRotationMatrix()
    CompilerEndIf
    
    Data.i @FromAngles()
    Data.i @Free()
    END_METHODS:
  EndDataSection
  
EndModule

; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
; <<<<< Code generated in : 00.001 seconds (150000.00 lines/second) <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

; <<<<<<<<<<<<<<<<<<<<<<<
; <<<<< END OF FILE <<<<<
; <<<<<<<<<<<<<<<<<<<<<<<
; IDE Options = PureBasic 6.00 LTS (Linux - x64)
; Folding = ----0------
; EnableXP
; CompileSourceDirectory